{"modifier-keys/caps_lock-to-hyper":"let rules = [\n  rule('Caps Lock ‚Üí Hyper').manipulators([\n    map('caps_lock').toHyper().toIfAlone('caps_lock'),\n  ]),\n]\n","modifier-keys/duo-modifiers":"let rules = [\n  rule('duo-modifiers').manipulators(\n    duoModifiers({\n      '‚åò': ['fd', 'jk'], // ‚åò first as used the most\n      '‚åÉ': ['fs', 'jl'], // ‚åÉ second as Vim uses it\n      '‚å•': ['fa', 'j;'], // ‚å• last as used the least\n\n      '‚áß': ['ds', 'kl'],\n\n      '‚åò‚áß': ['gd', 'hk'],\n      '‚åÉ‚áß': ['gs', 'hl'],\n      '‚å•‚áß': ['ga', 'h;'],\n\n      '‚åò‚å•': ['vc', 'm,'],\n      '‚åò‚åÉ': ['vx', 'm.'],\n      '‚å•‚åÉ': ['cx', ',.'],\n\n      '‚åò‚å•‚åÉ': ['vz', 'm/'],\n    }),\n  ),\n]\n\nfunction duoModifiers(\n  v: Partial<\n    Record<\n      '‚åò' | '‚å•' | '‚åÉ' | '‚áß' | MultiModifierAlias,\n      `${LetterKeyCode | KeyAlias}${LetterKeyCode | KeyAlias}`[]\n    >\n  >,\n) {\n  let result = []\n\n  for (let [m, k] of Object.entries(v)) {\n    for (let keys of k) {\n      let id = k + m\n      let [firstMod, ...restMods] = (\n        m in modifierKeyAliases\n          ? [modifierKeyAliases[m as ModifierKeyAlias]]\n          : multiModifierAliases[m as MultiModifierAlias]\n      ) as Array<'command' | 'control' | 'option' | 'shift'>\n\n      let to_after_key_up = [toRemoveNotificationMessage(id)]\n      result.push(\n        mapSimultaneous(keys.split('') as (LetterKeyCode | KeyAlias)[], {\n          to_after_key_up,\n        })\n          .toNotificationMessage(id, m) // Must go first or to() doesn't work\n          .to(`left_${firstMod}`, restMods),\n      )\n    }\n  }\n\n  return result\n}\n","os-functionality/launch-apps-layer":"let rules = [\n  layer('l', 'launch-app').manipulators({\n    c: toApp('Calendar'),\n    f: toApp('Finder'),\n  }),\n]\n","os-functionality/launch-apps-modifier":"let rules = [\n  rule('Launch Apps').manipulators([\n    withModifier('right_control')({\n      c: toApp('Calendar'),\n      f: toApp('Finder'),\n    }),\n  ]),\n]\n","vim/nested-leader-key":"let raycastEmoji = 'raycast/emoji-symbols/search-emoji-symbols'\nlet escape = [toUnsetVar('leader'), toRemoveNotificationMessage('leader')]\n\nlet rules = [\n  rule('Leader Key').manipulators([\n    // When no leader key or nested leader key is on\n    withCondition(ifVar('leader', 0))([\n      // Leader key\n      map('l', 'Hyper') // Or mapSimultaneous(['l', ';']) ...\n        .toVar('leader', 1)\n        .toNotificationMessage('leader', 'Leader Key: Open, Raycast, ...'),\n    ]),\n\n    // When leader key or nested leader key is on\n    withCondition(ifVar('leader', 0).unless())([\n      // Escape key(s)\n      map('escape').to(escape),\n    ]),\n\n    // When leader key but no nested leader key is on\n    withCondition(ifVar('leader', 1))([\n      // Nested leader keys\n      withMapper(['o', 'r'])((x) =>\n        map(x)\n          .toVar('leader', x)\n          .toNotificationMessage('leader', `leader ${x}`),\n      ),\n    ]),\n\n    // leader o - Open\n    withCondition(ifVar('leader', 'o'))(\n      [\n        map('f').toApp('Finder'),\n        // f - Finder, ...\n      ].map((x) => x.to(escape)),\n    ),\n\n    // leader r - Raycast\n    withCondition(ifVar('leader', 'r'))(\n      [\n        map('e').to$(`open raycast://extensions/${raycastEmoji}`),\n        // e - Emoji, ...\n      ].map((x) => x.to(escape)),\n    ),\n  ]),\n]\n","text-input/emoji":"let rules = [\n  layer('z', 'emoji').manipulators({\n    j: toPaste('üòÇ'), // joy\n  }),\n]\n","text-input/symbols":"let rules = [\n  layer('z', 'symbols').manipulators([\n    withMapper(['‚Üê', '‚Üí', '‚Üë', '‚Üì', '‚ê£', '‚èé', '‚å´', '‚å¶'])((k) =>\n      map(k).toPaste(k),\n    ),\n\n    { ',': toPaste('‚Äπ'), '.': toPaste('‚Ä∫') },\n\n    withMapper({ 4: '‚á•', 5: '‚éã', 6: '‚åò', 7: '‚å•', 8: '‚åÉ', 9: '‚áß', 0: '‚á™' })(\n      (k, v) => map(k).toPaste(v),\n    ),\n  ]),\n]\n"}